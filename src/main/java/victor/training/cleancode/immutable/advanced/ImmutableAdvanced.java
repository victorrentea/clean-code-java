package victor.training.cleancode.immutable.advanced;

import com.google.common.collect.ImmutableList;
import lombok.Builder;
import lombok.With;

import java.util.stream.Stream;

import static com.google.common.collect.ImmutableList.toImmutableList;

public class ImmutableAdvanced {
  public static void main(String[] args) {
    var list = Stream.of(1, 2, 3).collect(toImmutableList()); // ArrayList

    Immutable immutable = new Immutable(1, 2, list, new Other(15));
    System.out.println("Before: " + immutable);
//    list.clear();

    // avoid re-assigning variable
//    immutable = wilderness(immutable);
    var translatedImmutable = wilderness(immutable);

    System.out.println("After:  " + translatedImmutable);
  }

  //  private static Point wilderness(Immutable immutable) {
  private static Immutable wilderness(Immutable immutable) {
    // dark, deep logic not expected to change the immutable object x,y
//    immutable.list().clear();
    // I MUST "change" x,y, to add +1
//    return immutable.withXY(immutable.x() + 1, immutable.y() + 1);
//    immutable.withX()// generated by @With lombok
//    immutable.toBuilder().x(3).y(7).build(); //
    return immutable.translate(1, 1);

    // TODO extract a Point(x,y) and have the method return out ONLY THE new Point
  }


}

record Point(int x, int y) {
}

@Builder(toBuilder = true)
record Immutable(
    @With
    Integer x,
    Integer y,
//    Point point,
    ImmutableList<Integer> list,
    Other other) {
  public Immutable withXY(int x, int y) { // wither
    return new Immutable(x, y, list(), other());
  }
  public Immutable translate(int dx, int dy) { // more semantic
    return new Immutable(x + dx, y + dy, list, other);
  }
}

//class Immutable {
//  private final Integer x;
//  private final Integer y;
//  //  private final ImmutableList<Integer> list; // best from guava
//  private final List<Integer> list;
//  private final Other other;
//
//  Immutable(Integer x, Integer y, List<Integer> list, Other other) {
//    this.x = x;
//    this.y = y;
//    this.list = list;// protect against others keeping a ref to the mutable arraylist.
//    this.other = other;
//  }
//
////  public Stream<Integer> getList() {
////  public Iterator<Integer> getList() {
////  public Iterable<Integer> getList() { // okish
//
//  public List<Integer> getList() {

////    return new ArrayList<>(list); // malloc
//    return Collections.unmodifiableList(list); // immutable decorator
//  }
//
//  public Integer getX() {
//    return x;
//  }
//
//  public Integer getY() {
//    return y;
//  }
//
//  public Other getOther() {
//    return other;
//  }
//
//  @Override
//  public String toString() {
//    return "Immutable{x=%d, y=%d, numbers=%s, other=%s}".formatted(x, y, list, other);
//  }
//}

record Other(int a) { // j17+
}

//@Value // = generates final class, getter, ctor,tostring, hahscode...
//class Other {
//  int a;
//}
