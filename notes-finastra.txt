Here is the detailed agenda. I will roughly stick to the order of the items in each day. The items marked with * will come last during the day.
Plan (for 4 days x 5 hours each)

Day 1:
====
- Quiz Clean Code 101
- Fundamental Principles: SRP, DRY, KISS, Separation by Layers of Abstraction
====
- Refactoring Opportunities (debate): Boy Scout, Preparatory, Comprehension, Planned + micro commits
====
- Refactoring Exercise: baby-steps safe changes; practice: extract/Inline of Method, Quick-fix (Ctrl-1/Alt-Enter).
    - Guard Conditions
    - Comparing IntelliJ with Eclipse
====
- Code Review of 2 assignments (trivia-kata)*

Day 2: Object-Oriented Programming practices
====
- Hands-on refactoring of a sample from LoanIQ (ISO Exercise)
    - see lessons learned in the "ISO Exercise take-aways" section
====
- Refactoring exercise: Boss.java
    - ImmutableList (Guava) over List
    - Mutation testing = tests should fail for bugs in tested code
    - Split Loop refactor
    - Replace for with stream (FP)
==== lunch
- Encapsulation, Behavior next to state; Interval example
- Refactoring (all hands): Move method, Extract Value Object (Interval)
====
- MicroTypes vs Primitive Obsession
- Refactoring: Introduce Parameter Object
- Structural Replace in IntelliJ



Day 3: Functional Programming practices
- Exercise on P2G: move to stream, pure functions, immutability
===
- Pure Functions, Functional Core/Imperative Shell 
- Immutable Objects: builder (anti)pattern, withers, performance
===
- Immutable+Pure recap
- Optional (ab)use
===
- Code Smells - part 1

Day 4: 
- Code Smells - part 2
- Java Language Weaknesses
- Larger refactoring exercise 2h
- Using AI in Code
- Grand Recap & Next Steps *


- Exceptions best practices??
- Mastering Streams - Exercises > POSTPONE for Java lang features


TODO leftover : 
- Inheritance (use and abuse) --> Design Patterns
- P2G ~ GPP 


======= Coach Learning Journey =======
* Prep-meeting
- Duration: 1 hour
- Timeframe: April 8, 13:00-14:00 RO time, 1 week before the workshop
- Mandatory: yes
- Goals:
    - Introduce themselves, their experience, and their expectations
    - Discuss the main pain points they saw in the codebase.
    - Introduce Victor to 1-2 code samples manifesting issues (that we could refactor during the workshop)

* Workshop
- Duration: 4 days x 5 effective hours
- Date: April 15-18, 2024
- Mandatory? Attending all the 20 hours is highly recommended for everyone (including coaches), as it's expected for many debates to happen on the spot, when we touch on a topic. However, if your schedule is under heavy stress, please join at least the hour, during which we'll recap the main takeaways of the day and debate tradeoffs.
- Agenda/Goals: communicated to everyone

* Follow-up meeting with Coaches
- Duration: 2 hours
- Date: April 18, 16:00-18:00 RO time, after the last training section.
- Mandatory: yes
- Goal: Open questions, teamwork, code review, pair programming, role of a senior, next steps.

* Grooming an Internal Community
- After the workshop, answer questions from the participants in a dedicated Slack channel. Try to keep the conversation going for as long as possible, to help them apply the principles learned during the workshop.

* Ensamble Programming (without Victor)
- Duration: 2 hours
- Date: TBD internally, within 2-4 weeks after the workshop
- Goal: practice remote mob programming with the team, to see how they apply the principles learned during the workshop. Iteration #1: on some pre-made exercise. Iteration #2: on a real-life code snippet from the codebase.



=== Coaches: 
Sandeepüíñ LIQ: Code + review, Loan IQ, 17y
Shrutiüíñüí¨ LIQ: Leading a team in Loan IQ, 8.5y, design patterns, FP
Yashaswini ?: UI migrating from Dojo->Angular, Monolith BE->Cloud
Sadasivarao ?:
Ashish
Abhjit

Pratiküíñüí¨ P2G: C++ backend, Java since 4 years
Maulik P2G: on UI (+Components) and a bit of BE
Avi Sulimanoff P2G: 15 years, architect
Diklaüíñ P2G: Architect
Susil P2G: Sr. dev manager, 13y Java, code review
Guy P2G: .NET/Node/JS/Angular - UI
Yossiüí¨ (pairing)
Yossiüí¨ (pairing)

Kalpana FCC ~ lending

P2P = saas ~ GPP (global pay plus)

Coach Follow-up 2 hours after Clean Code
- Migrate from Eclipse to IntelliJ needs time (after a release)
    - re-setup the IDE (2-3 days min)
    - power of habbit (1-2 months to be 100% up to speed)
    - Eclipse hot-swapps the changed bytecode in the WebLogic(Eclipse)
        while IntelliJ -> JBoss not as perfect
        Tomcat(WAR) automatically
        Things to try:
        a) https://www.jrebel.com/products/jrebel
        b) start the app server in debug mode and IJ/EC hot-swaps the bytecode in your running app.
        if you can't fix this, stick to Eclipse and use IntelliJ for refactoring only.
- Ask & CHECK your team members read:
    - Chapter 1-11+17 from https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882
    - Chapter 2+3 + other on demand from https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599
- Practice with them on artifical fun refactoring exercises to practice skills https://kata-log.rocks/refactoring  you do yourself alone before , and then with a 3-7 people group/team.
    - Maulik extracted refactoring samples and wrote tests to prove the refactoring is correct. And will play together on those samples.
        Pair Programming constantly.
    - get together and let people work independently in pair on some simpel code refactorign kata.
    The breakthough of reducing 50 -> 5 lines of code is huge!!
    Get the passion back;

- Learning Hours: https://sammancoaching.org/learning_hours/legacy.html
- Bus Factor = the amount of people in a team that have to be ran over by a bus for the project to be in trouble

What to do to improve our codebase:
- practice
- gain control of your code: reflection, customer scripts
- upgrade the utility classes/framewokr underneath you: eg BOBase
    - synctactic tiny refactorings 1/ sprint
        - f(g(a),p1,p2...) ==> f2(a,p1,p2...)
        - or at least, regex
    - 
- Managers always rush us, Tech leads always care for the codebase quality, and to protect the less experience aganst the stress from above, to grant the less expereinced time to learn and grow. do the job so that they can do the job.
- help them grow, even if it seems counter productive
- always ask them: "Can you do better?"
- checklist for code review + writing

What stopped you from cleaning more? = TIME-PRESSURE
- people to understand that cleaning code is very important.
    Other teams / manager wait for me.
    We rush to meet the deadline. "We'll do it later"
    Eventually we forget to clean after.
    eg: JUnit in the plan. then everyone forgot about it.
        > the first thing you review are the tests -> if missing: reject by default.

- Don't know where to start? 
    - Cost/ROI/benefit analysis
    - don't start with the worst code according to sonar/smell
    - start with the code that produces most pain: bugs,delays,headaches,frustration: git heatmap = in what clases did we have the most bugs/commits in the last 6 months
    - start small (boy-scout): safe
    - do an analysis: exploratory refactoring sessions: 4h-5days
    2-3 "tigers" play with code to setup some milestones/phases

same task
1) no unit tests: 1h spec, 8h impelement + 3h late mails / calls
2) with unit tests: 3-5 tests+spec + 0-8h refactoring legacy to squeeze tests, 1h mails + implements 3-4h

        
- Should we put behavior in data structures? pros/cons  /risks
- Stream<>
- Platform of P2G


- Refactoring on FCC code - 1 hour 





=========== Clean Code Notes ===========

- When you raise a PR, put inside many tiny commits, to explain your train of thoughts to the reviewer. 
- Ideally, use commit prefixes (conventionalcommits.org) to fine-grain explain what you did in that commits. 
[bugfix] 
[refactor] broke the class in 3 .. 
[feature] added a button...
- Ideally commit tiny diffs (every 30 min/50 lines, 10/day)


---------------
Covered:
- SRP + overdo
- DRY + overdo
- KISS (briefly)
- SLAb (briefly)
CC:
- Microcommits / Conventional commits.





---- ISO Exercise take-aways (LoanIQ) ----
- methods should return as narrow types possible
- use generics! at least <StObject>
- write(generate w/ Copilot) tests for the code you want to refactor + prove those tests Are correct by tentatively breaking tested code => the tests should fail (mutation testing) . try pitest https://pitest.org/
- declutter main logic
    - enrich the utility classes with more helpful methods (+ ...varargs)
    - push more cast in 'Class' files extends StClass
    - use Java 5 for (:)
    - public static <T> T to avoid a cast
- avoid unnecessary utility functions (eg CollectionUtils.iterator(list), concat(s1,s2))
- for -> .stream


Tests the tests
You usually use a lot of refactoring/Ctrl-1/Alt-Enter to do safe refactoring with IDE.
Until you need to do a more risky change. (manually, ctrl-x, typing code). 
Imagine you write some code that you see it's buggy (obviously).
Run your unit tests!!!!!
a) GOOD: tests fail, proving they catch that mistake = "test the tests"
b) BAD: Tests keep on green / I don't have tests
THEN: STOP!!!!!! and write the missing tests to prove the bug you did.
c) stop/undo the manual refactoring. only use IDE refactoring tools




Split the for loops to do ONE tiny thing at a time.
- Performance? NO HIT unless the response time is < 50 microseconds (10^-6 seconds)
If I iterate over 1M elements, the overhead of Stream() could hurt.
Q: where did that 1M lines come from?
a) DB/Redis (usual) => the overhead of Stream() is negligible compared to bringing 1M elements over network
b) In-memory data structure (access time=0)

- Will this pass the tests: usually yes
    BUT if the order of the operations per element matters (WHY?!! does it matter), then breaking the for might produce a bug

- is this better reading code?
    a) split small intentful functions
    b) go for stream() instead of for to compute a result. Better?
        Most java developers would say YES.
        More declarative, more high-level
        (once you're confortable with streams)
        Practice here: https://github.com/victorrentea/kata-streams-java

- do I want to COMMIT element by element inependently to DB? > stick with for (e:elems) process(e);    
    process(e) {asdasdasdas; commit()}


Upgrade all code everywhere in small increments with  
Edit>Find>"Replace Structurally" with IntelliJ 
   Tutorial: https://www.youtube.com/watch?time_continue=95&v=fIPr_ANBpFk&embeds_referring_euri=https%3A%2F%2Fwww.google.com%2F&source_ve_path=Mjg2NjY&feature=emb_logo

Search Template:
StringUtility.bindWith(iso.Messages.liqNlsExternalizedMessage($Message$),$Parameter$)

Replace Template: 
iso.StringUtility.bindNlsWith($Message$, $Parameter$)




====
For loop -> Stream
- more compact, descriptive not low-level, but unknown to many devs
- Action: give it a try
- https://github.com/victorrentea/kata-streams-java
- https://www.youtube.com/watch?v=yTuwi--LFsM

Pure Functions = no side effects + deterministic
= no network, no changes to data, no time/random
- Good because: easy to maintain/refactor, clear input, easy to test, thread safe,
- Risk: a pure function today become inpure tomorrow .
    Examples that work: "any function whose name does not contain a verb is a pure function"
    customer.gold()
    customer.lastOrder()
    bank.nonDefaultOffices()

Immutable Objects = cannot change state after instantiation
- Shallow vs Deep immutable objects
- Good because: prevent "accidental" changes in complex logic
- Cons: cumbersome to keep re-creating & returning new objects (withers: obj.withPoint(newPoint))
- Cons: repeated cloning of immutables collections can lead to performance issues (allocating too much memory)
- Best if kept small!!! 
- group data in immutable objects EXCEPT the root top-level domain entites


"Functional Programming" is a programming paradigm 
- in which functions are treated as first-class citizens.
- we promote the use of pure functions, immutability, and declarative programming.


Yossi: if all our fields can NOW be null, should we make them all Optional?
NO!
Optionals are BEST used to enfoce a NULL-SAFE codebase.




SLAB = Single Level of Abstraction Principle
Do not mix in a method high-level logic with low-level details (push details in  private helper methods next to you)


JPA Tricks
https://www.youtube.com/watch?v=iw0tOx7Zbjc&list=PLggcOULvfLL_MfFS_O0MKQ5W_6oWWbIw5&index=42&t=3108s 










- Refactoring is NOT an option, it should become habbit.
- do small incremental changes (Boy-Scout style) wherever you go
- make extensive use of IntelliJ refactoring tools instead of typing/ctrl-x
    !! Explore them, hit ALT-ENTER (IntelliJ) / Ctrl-1 (Eclipse) 
    it's like muscle memory; Eg:  rename, extract, inline
- make sure non-automated changes are covered by unit tests (write them first)
    ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è HAVE THOSE TESTS BEHIND YOU WHEN YOU DO MANUAL CHANGES ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
- DO NOT change any behavior (even if you think it's a bug) when refactoring
    refactor=change structure, not behavior to make it easier to understand
- Beware of LLM (GitHub Copilot)
- practice, practice, practice
- Clean code from day 1 (at least before you submit the PR)
- Read/Watch Clean Code by Uncle Bob